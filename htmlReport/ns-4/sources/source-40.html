


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > OrderService</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.openmrs.api</a>
</div>

<h1>Coverage Summary for Class: OrderService (org.openmrs.api)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
</tr>
<tr>
  <td class="name">OrderService</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/**
&nbsp; * This Source Code Form is subject to the terms of the Mozilla Public License,
&nbsp; * v. 2.0. If a copy of the MPL was not distributed with this file, You can
&nbsp; * obtain one at http://mozilla.org/MPL/2.0/. OpenMRS is also distributed under
&nbsp; * the terms of the Healthcare Disclaimer located at http://openmrs.org/license.
&nbsp; *
&nbsp; * Copyright (C) OpenMRS Inc. OpenMRS is a registered trademark and the OpenMRS
&nbsp; * graphic logo is a trademark of OpenMRS Inc.
&nbsp; */
&nbsp;package org.openmrs.api;
&nbsp;
&nbsp;import org.openmrs.OrderAttribute;
&nbsp;import org.openmrs.OrderAttributeType;
&nbsp;import org.openmrs.Provider;
&nbsp;import org.openmrs.Visit;
&nbsp;import org.openmrs.OrderGroup;
&nbsp;import org.openmrs.OrderGroupAttribute;
&nbsp;import org.openmrs.OrderGroupAttributeType;
&nbsp;import org.openmrs.Order;
&nbsp;import org.openmrs.Patient;
&nbsp;import org.openmrs.CareSetting;
&nbsp;import org.openmrs.OrderType;
&nbsp;import org.openmrs.Concept;
&nbsp;import org.openmrs.ConceptClass;
&nbsp;import org.openmrs.Encounter;
&nbsp;import org.openmrs.OrderFrequency;
&nbsp;import org.openmrs.annotation.Authorized;
&nbsp;import org.openmrs.api.db.OrderDAO;
&nbsp;import org.openmrs.parameter.OrderSearchCriteria;
&nbsp;import org.openmrs.util.OpenmrsConstants;
&nbsp;import org.openmrs.util.PrivilegeConstants;
&nbsp;
&nbsp;import java.util.Date;
&nbsp;import java.util.List;
&nbsp;import java.util.Locale;
&nbsp;
&nbsp;/**
&nbsp; * Contains methods pertaining to creating/deleting/voiding Orders
&nbsp; */
&nbsp;public interface OrderService extends OpenmrsService {
&nbsp;	
&nbsp;	public static final String PARALLEL_ORDERS = &quot;PARALLEL_ORDERS&quot;;
&nbsp;	
&nbsp;	/**
&nbsp;	 * Setter for the Order data access object. The dao is used for saving and getting orders
&nbsp;	 * to/from the database
&nbsp;	 * 
&nbsp;	 * @param dao The data access object to use
&nbsp;	 */
&nbsp;	public void setOrderDAO(OrderDAO dao);
&nbsp;	
&nbsp;	/**
&nbsp;	 * Save or update the given &lt;code&gt;order&lt;/code&gt; in the database. If the OrderType for the order
&nbsp;	 * is not specified, then it will be set to the one set on the OrderContext if any, if none
&nbsp;	 * exists on the orderContext, then it will be set to the one associated to the ConceptClass of
&nbsp;	 * the ordered concept otherwise the save fails. If the CareSetting field of the order is not
&nbsp;	 * specified then it will default to the one set on the passed in OrderContext if any otherwise
&nbsp;	 * the save fails.
&nbsp;	 * 
&nbsp;	 * @param order the Order to save
&nbsp;	 * @param orderContext the OrderContext object
&nbsp;	 * @return the Order that was saved
&nbsp;	 * @throws APIException
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; not save order if order doesnt validate
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; discontinue existing active order if new order being saved with action to discontinue
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; pass if the existing drug order matches the concept and drug of the DC order
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; fail if the existing drug order matches the concept and not drug of the DC order
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; discontinue previousOrder if it is not already discontinued
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; fail if concept in previous order does not match this concept
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; not allow editing an existing order
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; not allow revising a voided order
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; not allow revising a stopped order
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; not allow revising an expired order
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; not allow revising an order with no previous order
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; save a revised order
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; save a revised order for a scheduled order which is not started
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; set order number specified in the context if specified
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; set the order number returned by the configured generator
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; set order type if null but mapped to the concept class
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; fail if order type is null and not mapped to the concept class
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; default to care setting and order type defined in the order context if null
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; not allow changing the patient of the previous order when revising an order
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; not allow changing the careSetting of the previous order when revising an order
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; not allow changing the concept of the previous order when revising an order
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; not allow changing the drug of the previous drug order when revising an order
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; fail if concept in previous order does not match that of the revised order
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; fail if the existing drug order matches the concept and not drug of the revised order
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; fail if the order type of the previous order does not match
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; fail if the java type of the previous order does not match
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; fail if the careSetting of the previous order does not match
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; set concept for drug orders if null
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; pass for a discontinuation order with no previous order
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; fail if an active drug order for the same concept and care setting exists
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; pass if an active test order for the same concept and care setting exists
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; pass if an active order for the same concept exists in a different care setting
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; set Order type of Drug Order to drug order if not set and concept not mapped
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; set Order type of Test Order to test order if not set and concept not mapped
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; throw AmbiguousOrderException if an active drug order for the same drug formulation
&nbsp;	 *         exists
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; pass if an active order for the same concept exists in a different care setting
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; fail for revision order if an active drug order for the same concept and care
&nbsp;	 *         settings exists
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; pass for revision order if an active test order for the same concept and care
&nbsp;	 *         settings exists
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; roll the autoExpireDate to the end of the day if it has no time component
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; not change the autoExpireDate if it has a time component
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; throw AmbiguousOrderException if disconnecting multiple active orders for the given
&nbsp;	 *         concept
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; throw AmbiguousOrderException if disconnecting multiple active drug orders with the
&nbsp;	 *         same drug
&nbsp;	 */
&nbsp;	@Authorized({ PrivilegeConstants.EDIT_ORDERS, PrivilegeConstants.ADD_ORDERS })
&nbsp;	public Order saveOrder(Order order, OrderContext orderContext) throws APIException;
&nbsp;	
&nbsp;	/**
&nbsp;	 * Save or update the given retrospective &lt;code&gt;order&lt;/code&gt; in the database. If the OrderType
&nbsp;	 * for the order is not specified, then it will be set to the one set on the OrderContext if
&nbsp;	 * any, if none exists on the orderContext, then it will be set to the one associated to the
&nbsp;	 * ConceptClass of the ordered concept otherwise the save fails. If the CareSetting field of the
&nbsp;	 * order is not specified then it will default to the one set on the passed in OrderContext if
&nbsp;	 * any otherwise the save fails. Retrospective entry of orders can affect downstream systems
&nbsp;	 * that acts on orders created. Orders cannot be stopped if they are already stopped in
&nbsp;	 * retrospective entry.
&nbsp;	 *
&nbsp;	 * @param order the Order to save
&nbsp;	 * @param orderContext the OrderContext object
&nbsp;	 * @return the Order that was saved
&nbsp;	 * @throws APIException
&nbsp;	 * @see #saveOrder(Order, OrderContext)
&nbsp;	 */
&nbsp;	@Authorized({ PrivilegeConstants.EDIT_ORDERS, PrivilegeConstants.ADD_ORDERS })
&nbsp;	public Order saveRetrospectiveOrder(Order order, OrderContext orderContext);
&nbsp;	
&nbsp;	/**
&nbsp;	 * Completely delete an order from the database. This should not typically be used unless
&nbsp;	 * desperately needed. Most orders should just be voided. See {@link #voidOrder(Order, String)}
&nbsp;	 * 
&nbsp;	 * @param order The Order to remove from the system
&nbsp;	 * @throws APIException
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; delete order from the database
&nbsp;	 */
&nbsp;	@Authorized(PrivilegeConstants.PURGE_ORDERS)
&nbsp;	public void purgeOrder(Order order) throws APIException;
&nbsp;	
&nbsp;	/**
&nbsp;	 * Completely delete an order from the database. This should not typically be used unless
&nbsp;	 * desperately needed. Most orders should just be voided. See {@link #voidOrder(Order, String)}
&nbsp;	 * This method is different from purgeOrder(Order order) above: If param cascade is false will
&nbsp;	 * completely delete an order from the database period If param cascade is true will completely
&nbsp;	 * delete an order from the database and delete any Obs that references the Order.
&nbsp;	 * 
&nbsp;	 * @param order The Order to remove from the system
&nbsp;	 * @param cascade
&nbsp;	 * @throws APIException
&nbsp;	 * @since 1.9.4
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; delete any Obs associated to the order when cascade is true
&nbsp;	 */
&nbsp;	@Authorized(PrivilegeConstants.PURGE_ORDERS)
&nbsp;	public void purgeOrder(Order order, boolean cascade) throws APIException;
&nbsp;	
&nbsp;	/**
&nbsp;	 * Mark an order as voided. This functionally removes the Order from the system while keeping a
&nbsp;	 * semblance
&nbsp;	 * 
&nbsp;	 * @param voidReason String reason
&nbsp;	 * @param order Order to void
&nbsp;	 * @return the Order that was voided
&nbsp;	 * @throws APIException
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; void an order
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; unset dateStopped of the previous order if the specified order is a discontinuation
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; unset dateStopped of the previous order if the specified order is a revision
&nbsp;	 */
&nbsp;	@Authorized(PrivilegeConstants.DELETE_ORDERS)
&nbsp;	public Order voidOrder(Order order, String voidReason) throws APIException;
&nbsp;	
&nbsp;	/**
&nbsp;	 * Get order by internal primary key identifier
&nbsp;	 * 
&nbsp;	 * @param orderId internal order identifier
&nbsp;	 * @return order with given internal identifier
&nbsp;	 * @throws APIException
&nbsp;	 */
&nbsp;	@Authorized(PrivilegeConstants.GET_ORDERS)
&nbsp;	public Order getOrder(Integer orderId) throws APIException;
&nbsp;	
&nbsp;	/**
&nbsp;	 * Get Order by its UUID
&nbsp;	 * 
&nbsp;	 * @param uuid
&nbsp;	 * @return order or null
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; find object given valid uuid
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; return null if no object found with given uuid
&nbsp;	 */
&nbsp;	@Authorized(PrivilegeConstants.GET_ORDERS)
&nbsp;	public Order getOrderByUuid(String uuid) throws APIException;
&nbsp;	
&nbsp;	/**
&nbsp;	 * Get discontinuation order for the given order, it is the un voided discontinuation order with
&nbsp;	 * a previousOrder that matches the specified order.
&nbsp;	 * 
&nbsp;	 * @param order
&nbsp;	 * @return the discontinuation order or null if none
&nbsp;	 * @throws APIException
&nbsp;	 * @since 1.10
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; return discontinuation order if order has been discontinued
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; return null if order has not been discontinued
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; return null if dc order is voided
&nbsp;	 */
&nbsp;	@Authorized(PrivilegeConstants.GET_ORDERS)
&nbsp;	public Order getDiscontinuationOrder(Order order) throws APIException;
&nbsp;	
&nbsp;	/**
&nbsp;	 * Get revision order for the given order, it is the order with the changes that was created as
&nbsp;	 * a replacement for the specified order. In other words, it is the un voided revise order with
&nbsp;	 * a previousOrder that matches the specified order.
&nbsp;	 * 
&nbsp;	 * @param order
&nbsp;	 * @return the revision order or null if none
&nbsp;	 * @throws APIException
&nbsp;	 * @since 1.10
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; return revision order if order has been revised
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; return null if order has not been revised
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; not return a voided revision order
&nbsp;	 */
&nbsp;	@Authorized(PrivilegeConstants.GET_ORDERS)
&nbsp;	public Order getRevisionOrder(Order order) throws APIException;
&nbsp;	
&nbsp;	/**
&nbsp;	 * Gets all Orders that match the specified parameters excluding discontinuation orders
&nbsp;	 * 
&nbsp;	 * @param patient the patient to match on
&nbsp;	 * @param careSetting the CareSetting to match on
&nbsp;	 * @param orderType The OrderType to match on
&nbsp;	 * @param includeVoided Specifies whether voided orders should be included or not
&nbsp;	 * @return list of Orders matching the parameters
&nbsp;	 * @since 1.10
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; fail if patient is null
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; fail if careSetting is null
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; get the orders that match all the arguments
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; get all unvoided matches if includeVoided is set to false
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; include voided matches if includeVoided is set to true
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; include orders for sub types if order type is specified
&nbsp;	 */
&nbsp;	@Authorized(PrivilegeConstants.GET_ORDERS)
&nbsp;	public List&lt;Order&gt; getOrders(Patient patient, CareSetting careSetting, OrderType orderType, boolean includeVoided);
&nbsp;	
&nbsp;	/**
&nbsp;	 * Gets all orders for the specified patient including discontinuation orders
&nbsp;	 * 
&nbsp;	 * @param patient the patient to match on
&nbsp;	 * @return list of matching {@link org.openmrs.Order}
&nbsp;	 * @since 1.10
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; fail if patient is null
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; get all the orders for the specified patient
&nbsp;	 */
&nbsp;	@Authorized(PrivilegeConstants.GET_ORDERS)
&nbsp;	public List&lt;Order&gt; getAllOrdersByPatient(Patient patient);
&nbsp;
&nbsp;	/**
&nbsp;	 * Get all orders that match a variety of (nullable) criteria contained in the parameter object.
&nbsp;	 * Each extra value for a parameter that is provided acts as an &quot;and&quot; and will reduce the number of results returned
&nbsp;	 *
&nbsp;	 * @param orderSearchCriteria the object containing search parameters
&nbsp;	 * @return a list of orders matching the search criteria
&nbsp;	 * @since 2.2
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; get the order matching the search criteria
&nbsp;	 */
&nbsp;	@Authorized( { PrivilegeConstants.GET_ORDERS })
&nbsp;	public List&lt;Order&gt; getOrders(OrderSearchCriteria orderSearchCriteria);
&nbsp;	
&nbsp;	/**
&nbsp;	 * Unvoid order record. Reverse a previous call to {@link #voidOrder(Order, String)}
&nbsp;	 * 
&nbsp;	 * @param order order to be unvoided
&nbsp;	 * @return the Order that was unvoided
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; unvoid an order
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; stop the previous order if the specified order is a discontinuation
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; stop the previous order if the specified order is a revision
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; fail for a discontinuation order if the previousOrder is inactive
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; fail for a revise order if the previousOrder is inactive
&nbsp;	 */
&nbsp;	@Authorized(PrivilegeConstants.DELETE_ORDERS)
&nbsp;	public Order unvoidOrder(Order order) throws APIException;
&nbsp;	
&nbsp;	/**
&nbsp;	 * Updates the fulfillerStatus of an order and the related comment and finally persists it
&nbsp;	 *
&nbsp;	 * @param order order whose fulfillerStatus should be changed
&nbsp;	 * @param orderFulfillerStatus describes the new Order.FulfillerStatus the order should be set to
&nbsp;	 * @param fullFillerComment is a string which describes a comment that is set while changing the FulfillerStatus               
&nbsp;	 * @return the Order that is updated with an according fulfillerStatus and fulFillerComment
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; set the new fulfillerStatus
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; set the new fulFillerComment
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; not update fulfillerStatus or fulFillerComment if null passed in to that field
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; save the changed order
&nbsp;	 */
&nbsp;	@Authorized(PrivilegeConstants.EDIT_ORDERS)
&nbsp;	public Order updateOrderFulfillerStatus(Order order, Order.FulfillerStatus orderFulfillerStatus, String fullFillerComment);
&nbsp;	
&nbsp;	/**
&nbsp;	 * Updates the fulfillerStatus of an order and the related comment and finally persists it
&nbsp;	 *
&nbsp;	 * @param order order whose fulfillerStatus should be changed
&nbsp;	 * @param orderFulfillerStatus describes the new Order.FulfillerStatus the order should be set to
&nbsp;	 * @param fullFillerComment is a string which describes a comment that is set while changing the FulfillerStatus 
&nbsp;	 * @param accessionNumber is the accession number to set             
&nbsp;	 * @return the Order that is updated with an according fulfillerStatus and fulFillerComment and accession number
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; set the new fulfillerStatus
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; set the new fulFillerComment
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; set the new accessionNumber
&nbsp;	 *  &lt;strong&gt;Should&lt;/strong&gt; not update fulfillerStatus or fulFillerComment or accessionNumber if null passed in to that field
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; save the changed order
&nbsp;	 */
&nbsp;	@Authorized(PrivilegeConstants.EDIT_ORDERS)
&nbsp;	public Order updateOrderFulfillerStatus(Order order, Order.FulfillerStatus orderFulfillerStatus, String fullFillerComment, String accessionNumber);
&nbsp;	
&nbsp;	/**
&nbsp;	 * Gets the order identified by a given order number
&nbsp;	 * 
&nbsp;	 * @param orderNumber the order number
&nbsp;	 * @return the order object
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; find object given valid order number
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; return null if no object found with given order number
&nbsp;	 */
&nbsp;	@Authorized(PrivilegeConstants.GET_ORDERS)
&nbsp;	public Order getOrderByOrderNumber(String orderNumber);
&nbsp;	
&nbsp;	/**
&nbsp;	 * Gets all Order objects that use this Concept for a given patient. Orders will be returned in
&nbsp;	 * the order in which they occurred, i.e. sorted by startDate starting with the latest
&nbsp;	 * 
&nbsp;	 * @param patient the patient.
&nbsp;	 * @param concept the concept.
&nbsp;	 * @return the list of orders.
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; return orders with the given concept
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; return empty list for concept without orders
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; reject a null patient
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; reject a null concept
&nbsp;	 */
&nbsp;	@Authorized(PrivilegeConstants.GET_ORDERS)
&nbsp;	public List&lt;Order&gt; getOrderHistoryByConcept(Patient patient, Concept concept);
&nbsp;	
&nbsp;	/**
&nbsp;	 * Gets the next available order number seed
&nbsp;	 * 
&nbsp;	 * @return the order number seed
&nbsp;	 */
&nbsp;	@Authorized(PrivilegeConstants.ADD_ORDERS)
&nbsp;	public Long getNextOrderNumberSeedSequenceValue();
&nbsp;	
&nbsp;	/**
&nbsp;	 * Gets the order matching the specified order number and its previous orders in the ordering
&nbsp;	 * they occurred, i.e if this order has a previous order, fetch it and if it also has a previous
&nbsp;	 * order then fetch it until the original one with no previous order is reached
&nbsp;	 * 
&nbsp;	 * @param orderNumber the order number whose history to get
&nbsp;	 * @return a list of orders for given order number
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; return all order history for given order number
&nbsp;	 */
&nbsp;	@Authorized(PrivilegeConstants.GET_ORDERS)
&nbsp;	public List&lt;Order&gt; getOrderHistoryByOrderNumber(String orderNumber);
&nbsp;	
&nbsp;	/**
&nbsp;	 * Gets all active orders for the specified patient matching the specified CareSetting,
&nbsp;	 * OrderType as of the specified date. Below is the criteria for determining an active order:
&nbsp;	 * &lt;pre&gt;
&nbsp;	 * - Not voided
&nbsp;	 * - Not a discontinuation Order i.e one where action != Action#DISCONTINUE
&nbsp;	 * - dateActivated is before or equal to asOfDate
&nbsp;	 * - dateStopped and autoExpireDate are both null OR if it has dateStopped, then it should be
&nbsp;	 * after asOfDate OR if it has autoExpireDate, then it should be after asOfDate. NOTE: If both
&nbsp;	 * dateStopped and autoExpireDate are set then dateStopped wins because an order can never
&nbsp;	 * expire and then stopped later i.e. you stop an order that hasn&#39;t yet expired
&nbsp;	 * &lt;/pre&gt;
&nbsp;	 * 
&nbsp;	 * @param patient the patient
&nbsp;	 * @param orderType The OrderType to match
&nbsp;	 * @param careSetting the care setting, returns all ignoring care setting if value is null
&nbsp;	 * @param asOfDate defaults to current time
&nbsp;	 * @return all active orders for given patient parameters
&nbsp;	 * @since 1.10
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; return all active orders for the specified patient
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; return all active orders for the specified patient and care setting
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; return all active drug orders for the specified patient
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; return all active test orders for the specified patient
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; fail if patient is null
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; return active orders as of the specified date
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; return all orders if no orderType is specified
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; include orders for sub types if order type is specified
&nbsp;	 */
&nbsp;	@Authorized(PrivilegeConstants.GET_ORDERS)
&nbsp;	public List&lt;Order&gt; getActiveOrders(Patient patient, OrderType orderType, CareSetting careSetting, Date asOfDate);
&nbsp;	
&nbsp;	/**
&nbsp;	 * Retrieve care setting
&nbsp;	 * 
&nbsp;	 * @param careSettingId
&nbsp;	 * @return the care setting
&nbsp;	 * @since 1.10
&nbsp;	 */
&nbsp;	@Authorized(PrivilegeConstants.GET_CARE_SETTINGS)
&nbsp;	public CareSetting getCareSetting(Integer careSettingId);
&nbsp;	
&nbsp;	/**
&nbsp;	 * Gets the CareSetting with the specified uuid
&nbsp;	 * 
&nbsp;	 * @param uuid the uuid to match on
&nbsp;	 * @return CareSetting
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; return the care setting with the specified uuid
&nbsp;	 */
&nbsp;	@Authorized(PrivilegeConstants.GET_CARE_SETTINGS)
&nbsp;	public CareSetting getCareSettingByUuid(String uuid);
&nbsp;	
&nbsp;	/**
&nbsp;	 * Gets the CareSetting with the specified name
&nbsp;	 * 
&nbsp;	 * @param name the name to match on
&nbsp;	 * @return CareSetting
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; return the care setting with the specified name
&nbsp;	 */
&nbsp;	@Authorized(PrivilegeConstants.GET_CARE_SETTINGS)
&nbsp;	public CareSetting getCareSettingByName(String name);
&nbsp;	
&nbsp;	/**
&nbsp;	 * Gets all non retired CareSettings if includeRetired is set to true otherwise retired ones are
&nbsp;	 * included too
&nbsp;	 * 
&nbsp;	 * @param includeRetired specifies whether retired care settings should be returned or not
&nbsp;	 * @return A List of CareSettings
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; return only un retired care settings if includeRetired is set to false
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; return retired care settings if includeRetired is set to true
&nbsp;	 */
&nbsp;	@Authorized(PrivilegeConstants.GET_CARE_SETTINGS)
&nbsp;	public List&lt;CareSetting&gt; getCareSettings(boolean includeRetired);
&nbsp;	
&nbsp;	/**
&nbsp;	 * Gets OrderType that matches the specified name
&nbsp;	 * 
&nbsp;	 * @param orderTypeName the name to match against
&nbsp;	 * @return OrderType
&nbsp;	 * @since 1.10
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; return the order type that matches the specified name
&nbsp;	 */
&nbsp;	@Authorized(PrivilegeConstants.GET_ORDER_TYPES)
&nbsp;	public OrderType getOrderTypeByName(String orderTypeName);
&nbsp;	
&nbsp;	/**
&nbsp;	 * Gets OrderFrequency that matches the specified orderFrequencyId
&nbsp;	 * 
&nbsp;	 * @param orderFrequencyId the id to match against
&nbsp;	 * @return OrderFrequency
&nbsp;	 * @since 1.10
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; return the order frequency that matches the specified id
&nbsp;	 */
&nbsp;	@Authorized(PrivilegeConstants.GET_ORDER_FREQUENCIES)
&nbsp;	public OrderFrequency getOrderFrequency(Integer orderFrequencyId);
&nbsp;	
&nbsp;	/**
&nbsp;	 * Gets OrderFrequency that matches the specified uuid
&nbsp;	 * 
&nbsp;	 * @param uuid the uuid to match against
&nbsp;	 * @return OrderFrequency
&nbsp;	 * @since 1.10
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; return the order frequency that matches the specified uuid
&nbsp;	 */
&nbsp;	@Authorized(PrivilegeConstants.GET_ORDER_FREQUENCIES)
&nbsp;	public OrderFrequency getOrderFrequencyByUuid(String uuid);
&nbsp;	
&nbsp;	/**
&nbsp;	 * Gets an OrderFrequency that matches the specified concept
&nbsp;	 * 
&nbsp;	 * @param concept the concept to match against
&nbsp;	 * @return OrderFrequency
&nbsp;	 * @since 1.10
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; return the order frequency that matches the specified concept
&nbsp;	 */
&nbsp;	@Authorized(PrivilegeConstants.GET_ORDER_FREQUENCIES)
&nbsp;	public OrderFrequency getOrderFrequencyByConcept(Concept concept);
&nbsp;	
&nbsp;	/**
&nbsp;	 * Gets all order frequencies
&nbsp;	 * 
&nbsp;	 * @return List&amp;lt;OrderFrequency&amp;gt;
&nbsp;	 * @since 1.10
&nbsp;	 * @param includeRetired specifies whether retired ones should be included or not
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; return only non retired order frequencies if includeRetired is set to false
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; return all the order frequencies if includeRetired is set to true
&nbsp;	 */
&nbsp;	@Authorized(PrivilegeConstants.GET_ORDER_FREQUENCIES)
&nbsp;	public List&lt;OrderFrequency&gt; getOrderFrequencies(boolean includeRetired);
&nbsp;	
&nbsp;	/**
&nbsp;	 * Gets all non retired order frequencies associated to concepts that match the specified search
&nbsp;	 * phrase
&nbsp;	 * 
&nbsp;	 * @param searchPhrase The string to match on
&nbsp;	 * @param locale The locale to match on when searching in associated concept names
&nbsp;	 * @param exactLocale If false then order frequencies associated to concepts with names in a
&nbsp;	 *            broader locale will be matched e.g in case en_GB is passed in then en will be
&nbsp;	 *            matched
&nbsp;	 * @param includeRetired Specifies if retired order frequencies that match should be included or
&nbsp;	 *            not
&nbsp;	 * @return List&amp;lt;OrderFrequency&amp;gt;
&nbsp;	 * @since 1.10
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; get non retired frequencies with names matching the phrase if includeRetired is false
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; include retired frequencies if includeRetired is set to true
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; get frequencies with names that match the phrase and locales if exact locale is false
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; get frequencies with names that match the phrase and locale if exact locale is true
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; return unique frequencies
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; reject a null search phrase
&nbsp;	 */
&nbsp;	@Authorized(PrivilegeConstants.GET_ORDER_FREQUENCIES)
&nbsp;	public List&lt;OrderFrequency&gt; getOrderFrequencies(String searchPhrase, Locale locale, boolean exactLocale,
&nbsp;	        boolean includeRetired);
&nbsp;	
&nbsp;	/**
&nbsp;	 * Discontinues an order. Creates a new order that discontinues the orderToDiscontinue
&nbsp;	 * 
&nbsp;	 * @param orderToDiscontinue
&nbsp;	 * @param reasonCoded
&nbsp;	 * @param discontinueDate
&nbsp;	 * @param orderer
&nbsp;	 * @param encounter
&nbsp;	 * @return the new order that discontinued orderToDiscontinue
&nbsp;	 * @throws APIException if the &lt;code&gt;action&lt;/code&gt; of orderToDiscontinue is
&nbsp;	 *             &lt;code&gt;Order.Action.DISCONTINUE&lt;/code&gt;
&nbsp;	 * @since 1.10
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; set correct attributes on the discontinue and discontinued orders
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; pass for an active order which is scheduled and not started as of discontinue date
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; not pass for a discontinuation order
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; fail for a stopped order
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; fail for an expired order
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; reject a future discontinueDate
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; not pass for a discontinued order
&nbsp;	 */
&nbsp;	@Authorized({ PrivilegeConstants.ADD_ORDERS, PrivilegeConstants.EDIT_ORDERS })
&nbsp;	public Order discontinueOrder(Order orderToDiscontinue, Concept reasonCoded, Date discontinueDate, Provider orderer,
&nbsp;	        Encounter encounter);
&nbsp;	
&nbsp;	/**
&nbsp;	 * Discontinues an order. Creates a new order that discontinues the orderToDiscontinue.
&nbsp;	 * 
&nbsp;	 * @param orderToDiscontinue
&nbsp;	 * @param reasonNonCoded
&nbsp;	 * @param discontinueDate
&nbsp;	 * @param orderer
&nbsp;	 * @param encounter
&nbsp;	 * @return the new order that discontinued orderToDiscontinue
&nbsp;	 * @throws APIException if the &lt;code&gt;action&lt;/code&gt; of orderToDiscontinue is
&nbsp;	 *             &lt;code&gt;Order.Action.DISCONTINUE&lt;/code&gt;
&nbsp;	 * @since 1.10
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; populate correct attributes on the discontinue and discontinued orders
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; pass for an active order which is scheduled and not started as of discontinue date
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; fail for a discontinuation order
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; fail if discontinueDate is in the future
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; fail for a voided order
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; fail for a discontinued order
&nbsp;	 */
&nbsp;	@Authorized({ PrivilegeConstants.ADD_ORDERS, PrivilegeConstants.EDIT_ORDERS })
&nbsp;	public Order discontinueOrder(Order orderToDiscontinue, String reasonNonCoded, Date discontinueDate, Provider orderer,
&nbsp;	        Encounter encounter);
&nbsp;	
&nbsp;	/**
&nbsp;	 * Creates or updates the given order frequency in the database
&nbsp;	 * 
&nbsp;	 * @param orderFrequency the order frequency to save
&nbsp;	 * @return the order frequency created/saved
&nbsp;	 * @since 1.10
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; add a new order frequency to the database
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; edit an existing order frequency that is not in use
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; not allow editing an existing order frequency that is in use
&nbsp;	 */
&nbsp;	@Authorized(PrivilegeConstants.MANAGE_ORDER_FREQUENCIES)
&nbsp;	public OrderFrequency saveOrderFrequency(OrderFrequency orderFrequency) throws APIException;
&nbsp;	
&nbsp;	/**
&nbsp;	 * Retires the given order frequency in the database
&nbsp;	 * 
&nbsp;	 * @param orderFrequency the order frequency to retire
&nbsp;	 * @param reason the retire reason
&nbsp;	 * @return the retired order frequency
&nbsp;	 * @since 1.10
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; retire given order frequency
&nbsp;	 */
&nbsp;	@Authorized(PrivilegeConstants.MANAGE_ORDER_FREQUENCIES)
&nbsp;	public OrderFrequency retireOrderFrequency(OrderFrequency orderFrequency, String reason);
&nbsp;	
&nbsp;	/**
&nbsp;	 * Restores an order frequency that was previously retired in the database
&nbsp;	 * 
&nbsp;	 * @param orderFrequency the order frequency to unretire
&nbsp;	 * @return the unretired order frequency
&nbsp;	 * @since 1.10
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; unretire given order frequency
&nbsp;	 */
&nbsp;	@Authorized(PrivilegeConstants.MANAGE_ORDER_FREQUENCIES)
&nbsp;	public OrderFrequency unretireOrderFrequency(OrderFrequency orderFrequency);
&nbsp;	
&nbsp;	/**
&nbsp;	 * Completely removes an order frequency from the database
&nbsp;	 * 
&nbsp;	 * @param orderFrequency the order frequency to purge
&nbsp;	 * @since 1.10
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; delete given order frequency
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; not allow deleting an order frequency that is in use
&nbsp;	 */
&nbsp;	@Authorized(PrivilegeConstants.PURGE_ORDER_FREQUENCIES)
&nbsp;	public void purgeOrderFrequency(OrderFrequency orderFrequency) throws APIException;
&nbsp;	
&nbsp;	/**
&nbsp;	 * Get OrderType by orderTypeId
&nbsp;	 * 
&nbsp;	 * @param orderTypeId the orderTypeId to match on
&nbsp;	 * @since 1.10
&nbsp;	 * @return order type object associated with given id
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; find order type object given valid id
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; return null if no order type object found with given id
&nbsp;	 */
&nbsp;	@Authorized(PrivilegeConstants.GET_ORDER_TYPES)
&nbsp;	public OrderType getOrderType(Integer orderTypeId);
&nbsp;	
&nbsp;	/**
&nbsp;	 * Get OrderType by uuid
&nbsp;	 * 
&nbsp;	 * @param uuid the uuid to match on
&nbsp;	 * @since 1.10
&nbsp;	 * @return order type object associated with given uuid
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; find order type object given valid uuid
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; return null if no order type object found with given uuid
&nbsp;	 */
&nbsp;	@Authorized(PrivilegeConstants.GET_ORDER_TYPES)
&nbsp;	public OrderType getOrderTypeByUuid(String uuid);
&nbsp;	
&nbsp;	/**
&nbsp;	 * Get all order types, if includeRetired is set to true then retired ones will be included
&nbsp;	 * otherwise not
&nbsp;	 * 
&nbsp;	 * @param includeRetired boolean flag which indicate search needs to look at retired order types
&nbsp;	 *            or not
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; get all order types if includeRetired is set to true
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; get all non retired order types if includeRetired is set to false
&nbsp;	 * @return list of order types
&nbsp;	 * @since 1.10
&nbsp;	 */
&nbsp;	@Authorized(PrivilegeConstants.GET_ORDER_TYPES)
&nbsp;	public List&lt;OrderType&gt; getOrderTypes(boolean includeRetired);
&nbsp;	
&nbsp;	/**
&nbsp;	 * Creates or updates the given order type in the database
&nbsp;	 * 
&nbsp;	 * @param orderType the order type to save
&nbsp;	 * @return the order type created/saved
&nbsp;	 * @since 1.10
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; add a new order type to the database
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; edit an existing order type
&nbsp;	 */
&nbsp;	@Authorized(PrivilegeConstants.MANAGE_ORDER_TYPES)
&nbsp;	public OrderType saveOrderType(OrderType orderType);
&nbsp;	
&nbsp;	/**
&nbsp;	 * Completely removes an order type from the database
&nbsp;	 * 
&nbsp;	 * @param orderType the order type to purge
&nbsp;	 * @since 1.10
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; delete order type if not in use
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; not allow deleting an order type that is in use
&nbsp;	 */
&nbsp;	@Authorized(PrivilegeConstants.PURGE_ORDER_TYPES)
&nbsp;	public void purgeOrderType(OrderType orderType) throws APIException;
&nbsp;	
&nbsp;	/**
&nbsp;	 * Retires the given order type in the database
&nbsp;	 * 
&nbsp;	 * @param orderType the order type to retire
&nbsp;	 * @param reason the retire reason
&nbsp;	 * @return the retired order type
&nbsp;	 * @since 1.10
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; retire order type
&nbsp;	 */
&nbsp;	@Authorized(PrivilegeConstants.MANAGE_ORDER_TYPES)
&nbsp;	public OrderType retireOrderType(OrderType orderType, String reason);
&nbsp;	
&nbsp;	/**
&nbsp;	 * Restores an order type that was previously retired in the database
&nbsp;	 * 
&nbsp;	 * @param orderType the order type to unretire
&nbsp;	 * @return the unretired order type
&nbsp;	 * @since 1.10
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; unretire order type
&nbsp;	 */
&nbsp;	@Authorized(PrivilegeConstants.MANAGE_ORDER_TYPES)
&nbsp;	public OrderType unretireOrderType(OrderType orderType);
&nbsp;	
&nbsp;	/**
&nbsp;	 * Returns all descendants of a given order type for example Given TEST will get back LAB TEST
&nbsp;	 * and RADIOLOGY TEST; and Given LAB TEST, will might get back SEROLOGY, MICROBIOLOGY, and
&nbsp;	 * CHEMISTRY
&nbsp;	 * 
&nbsp;	 * @param orderType the order type which needs to search for its&#39; dependencies
&nbsp;	 * @param includeRetired boolean flag for include retired order types or not
&nbsp;	 * @return list of order type which matches the given order type
&nbsp;	 */
&nbsp;	@Authorized(PrivilegeConstants.GET_ORDER_TYPES)
&nbsp;	public List&lt;OrderType&gt; getSubtypes(OrderType orderType, boolean includeRetired);
&nbsp;	
&nbsp;	/**
&nbsp;	 * Gets the order type mapped to a given concept class
&nbsp;	 * 
&nbsp;	 * @param conceptClass the concept class
&nbsp;	 * @return the matching order type
&nbsp;	 * @since 1.10
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; get order type mapped to the given concept class
&nbsp;	 */
&nbsp;	@Authorized(PrivilegeConstants.GET_ORDER_TYPES)
&nbsp;	public OrderType getOrderTypeByConceptClass(ConceptClass conceptClass);
&nbsp;	
&nbsp;	/**
&nbsp;	 * Gets the order type mapped to a given concept
&nbsp;	 * 
&nbsp;	 * @param concept the concept
&nbsp;	 * @return the matching order type
&nbsp;	 * @since 1.10
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; get order type mapped to the given concept
&nbsp;	 */
&nbsp;	@Authorized(PrivilegeConstants.GET_ORDER_TYPES)
&nbsp;	public OrderType getOrderTypeByConcept(Concept concept);
&nbsp;	
&nbsp;	/**
&nbsp;	 * Gets the possible drug routes, i.e the set members for the concept that matches the uuid
&nbsp;	 * specified as the value for the global property
&nbsp;	 * {@link OpenmrsConstants#GP_DRUG_ROUTES_CONCEPT_UUID}
&nbsp;	 * 
&nbsp;	 * @return concept list of drug routes
&nbsp;	 * @since 1.10
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; return an empty list if nothing is configured
&nbsp;	 */
&nbsp;	@Authorized(PrivilegeConstants.GET_CONCEPTS)
&nbsp;	public List&lt;Concept&gt; getDrugRoutes();
&nbsp;	
&nbsp;	/**
&nbsp;	 * Gets the possible drug dosing units, i.e the set members for the concept that matches the
&nbsp;	 * uuid specified as the value for the global property
&nbsp;	 * {@link OpenmrsConstants#GP_DRUG_DOSING_UNITS_CONCEPT_UUID}
&nbsp;	 * 
&nbsp;	 * @return concept list of drug dosing units
&nbsp;	 * @since 1.10
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; return an empty list if nothing is configured
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; return a list if GP is set
&nbsp;	 */
&nbsp;	@Authorized(PrivilegeConstants.GET_CONCEPTS)
&nbsp;	public List&lt;Concept&gt; getDrugDosingUnits();
&nbsp;	
&nbsp;	/**
&nbsp;	 * Gets the possible units of dispensing, i.e the set members for the concept that matches the
&nbsp;	 * uuid specified as the value for the global property
&nbsp;	 * {@link OpenmrsConstants#GP_DRUG_DISPENSING_UNITS_CONCEPT_UUID}
&nbsp;	 * 
&nbsp;	 * @return concept list of units of dispensing
&nbsp;	 * @since 1.10
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; return an empty list if nothing is configured
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; return a list if GP is set
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; return the union of the dosing and dispensing units
&nbsp;	 */
&nbsp;	@Authorized(PrivilegeConstants.GET_CONCEPTS)
&nbsp;	public List&lt;Concept&gt; getDrugDispensingUnits();
&nbsp;	
&nbsp;	/**
&nbsp;	 * Gets the possible units of duration, i.e the set members for the concept that matches the
&nbsp;	 * uuid specified as the value for the global property
&nbsp;	 * {@link OpenmrsConstants#GP_DURATION_UNITS_CONCEPT_UUID}
&nbsp;	 * 
&nbsp;	 * @return concept list of units of duration
&nbsp;	 * @since 1.10
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; return an empty list if nothing is configured
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; return a list if GP is set
&nbsp;	 */
&nbsp;	@Authorized(PrivilegeConstants.GET_CONCEPTS)
&nbsp;	public List&lt;Concept&gt; getDurationUnits();
&nbsp;	
&nbsp;	/**
&nbsp;	 * Gets the possible test specimen sources, i.e the set members for the concept that matches the
&nbsp;	 * uuid specified as the value for the global property
&nbsp;	 * {@link OpenmrsConstants#GP_TEST_SPECIMEN_SOURCES_CONCEPT_UUID}
&nbsp;	 * 
&nbsp;	 * @return concept list of specimen sources
&nbsp;	 * @since 1.10
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; return an empty list if nothing is configured
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; return a list if GP is set
&nbsp;	 */
&nbsp;	@Authorized(PrivilegeConstants.GET_CONCEPTS)
&nbsp;	public List&lt;Concept&gt; getTestSpecimenSources();
&nbsp;	
&nbsp;	/**
&nbsp;	 * Gets the non coded drug concept, i.e the concept that matches the uuid specified as the value
&nbsp;	 * for the global property {@link OpenmrsConstants#GP_DRUG_ORDER_DRUG_OTHER
&nbsp;	 *
&nbsp;	 * @return concept of non coded drug
&nbsp;	 * @since 1.12
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; return null if nothing is configured
&nbsp;	 * &lt;strong&gt;Should&lt;/strong&gt; return a concept if GP is set
&nbsp;	 */
&nbsp;	@Authorized(PrivilegeConstants.GET_CONCEPTS)
&nbsp;	public Concept getNonCodedDrugConcept();
&nbsp;	
&nbsp;	/**
&nbsp;	 * Fetches the OrderGroup By Uuid.
&nbsp;	 * 
&nbsp;	 * @param uuid Uuid Of the OrderGroup
&nbsp;	 * @return saved OrderGroup
&nbsp;	 * @since 1.12
&nbsp;	 * @throws APIException
&nbsp;	 */
&nbsp;	@Authorized(PrivilegeConstants.GET_ORDERS)
&nbsp;	public OrderGroup getOrderGroupByUuid(String uuid) throws APIException;
&nbsp;	
&nbsp;	/**
&nbsp;	 * Fetches the OrderGroup by Id.
&nbsp;	 * 
&nbsp;	 * @param orderGroupId Id of the OrderGroup
&nbsp;	 * @return saved OrderGroup
&nbsp;	 * @since 1.12
&nbsp;	 * @throws APIException
&nbsp;	 */
&nbsp;	@Authorized(PrivilegeConstants.GET_ORDERS)
&nbsp;	public OrderGroup getOrderGroup(Integer orderGroupId) throws APIException;
&nbsp;	
&nbsp;	/**
&nbsp;	 * Saves the orderGroup. It also saves the list of orders that are present within the
&nbsp;	 * orderGroup.
&nbsp;	 *
&nbsp;	 * @param orderGroup the orderGroup to be saved
&nbsp;	 * @since 1.12
&nbsp;	 * @throws APIException
&nbsp;	 */
&nbsp;	@Authorized({ PrivilegeConstants.EDIT_ORDERS, PrivilegeConstants.ADD_ORDERS })
&nbsp;	public OrderGroup saveOrderGroup(OrderGroup orderGroup) throws APIException;
&nbsp;
&nbsp;	/**
&nbsp;	 * Saves an order group with a specific order context
&nbsp;	 *
&nbsp;	 * @param orderGroup the order group to be saved
&nbsp;	 * @param orderContext the order context data transfer object containing care setting and 
&nbsp;	 * the order type to save with the order group
&nbsp;	 * @return the order group that was saved with the specified order context data
&nbsp;	 * @since 2.7.0
&nbsp;	 * @throws APIException
&nbsp;	 */
&nbsp;	@Authorized({ PrivilegeConstants.EDIT_ORDERS, PrivilegeConstants.ADD_ORDERS })
&nbsp;	public  OrderGroup saveOrderGroup(OrderGroup orderGroup, OrderContext orderContext) throws APIException;
&nbsp;
&nbsp;	/**
&nbsp;	 * Fetches all order groups for the specified patient
&nbsp;	 * 
&nbsp;	 * @param patient the patient to match on
&nbsp;	 * @return list of matching OrderGroups
&nbsp;	 * @since 2.4.0
&nbsp;	 * @throws APIException
&nbsp;	 */
&nbsp;	@Authorized(PrivilegeConstants.GET_ORDERS)
&nbsp;	public List&lt;OrderGroup&gt; getOrderGroupsByPatient(Patient patient) throws APIException;
&nbsp;
&nbsp;	/**
&nbsp;	 * Fetches all order groups for the specified encounter
&nbsp;	 *
&nbsp;	 * @param encounter the encounter to match on
&nbsp;	 * @return list of matching OrderGroups
&nbsp;	 * @since 2.4.0
&nbsp;	 * @throws APIException
&nbsp;	 */
&nbsp;	@Authorized(PrivilegeConstants.GET_ORDERS)
&nbsp;	public List&lt;OrderGroup&gt; getOrderGroupsByEncounter(Encounter encounter) throws APIException;
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns all order group attribute types
&nbsp;	 *
&nbsp;	 * @return all {@link OrderGroupAttributeType}s
&nbsp;	 * @should return all order group attribute types including retired ones
&nbsp;	 */
&nbsp;	@Authorized(PrivilegeConstants.GET_ORDERS)
&nbsp;	 List&lt;OrderGroupAttributeType&gt; getAllOrderGroupAttributeTypes() throws APIException;
&nbsp;	
&nbsp;	/**
&nbsp;	 * Fetches order group attribute type using provided Id
&nbsp;	 * 
&nbsp;	 * @param id The Id of the order group attribute type to fetch from the database
&nbsp;	 * @return the {@link OrderGroupAttributeType} with the given internal id
&nbsp;	 * @should return the order group attribute type using the provided id
&nbsp;	 * @should return null if no order group attribute type exists with the given id
&nbsp;	 */
&nbsp;	@Authorized(PrivilegeConstants.GET_ORDERS)
&nbsp;	OrderGroupAttributeType getOrderGroupAttributeType(Integer orderGroupAttributeTypeId) throws APIException;
&nbsp;
&nbsp;	/**
&nbsp;	 * Fetches  order group attribute type using provided uuid
&nbsp;	 * 
&nbsp;	 * @param uuid The uuid of the order group attribute type to fetch from the database
&nbsp;	 * @return the {@link OrderGroupAttributeType} with the given uuid
&nbsp;	 * @should return the order group attribute type with the given uuid
&nbsp;	 * @should return null if no order group attribute type exists with the given uuid
&nbsp;	 */
&nbsp;	OrderGroupAttributeType getOrderGroupAttributeTypeByUuid(String uuid) throws APIException;
&nbsp;	
&nbsp;	/**
&nbsp;	 * Creates or updates the given order group attribute type in the database
&nbsp;	 *
&nbsp;	 * @param orderGroupAttributeType The order group attribute type to save in the database
&nbsp;	 * @return the order group attribute type created or saved
&nbsp;	 * @should create a new order group attribute type
&nbsp;	 * @should edit an existing order group attribute type
&nbsp;	 */
&nbsp;    @Authorized({PrivilegeConstants.EDIT_ORDERS,PrivilegeConstants.ADD_ORDERS})
&nbsp;	OrderGroupAttributeType saveOrderGroupAttributeType(OrderGroupAttributeType orderGroupAttributeType) throws APIException;
&nbsp;
&nbsp;	/**
&nbsp;	 * Retires the given order group attribute type in the database
&nbsp;	 *
&nbsp;	 * @param orderGroupAttributeType The order group attribute type to retire
&nbsp;	 * @param reason The reason why the order group attribute type is being retired
&nbsp;	 * @return the order group attribute type retired
&nbsp;	 * @should retire an order group attribute type
&nbsp;	 */
&nbsp;	@Authorized(PrivilegeConstants.MANAGE_ORDER_TYPES)
&nbsp;	OrderGroupAttributeType retireOrderGroupAttributeType(OrderGroupAttributeType orderGroupAttributeType, String reason) throws APIException;
&nbsp;
&nbsp;	/**
&nbsp;	 * Restores an order group attribute type that was previously retired in the database
&nbsp;	 * 
&nbsp;	 * @param orderGroupAttributeType The order group attribute type to unretire
&nbsp;	 * @return the order group attribute type unretired
&nbsp;	 * @should unretire an order group attribute type
&nbsp;	 */
&nbsp;	@Authorized(PrivilegeConstants.MANAGE_ORDER_TYPES)
&nbsp;	OrderGroupAttributeType unretireOrderGroupAttributeType(OrderGroupAttributeType orderGroupAttributeType) throws APIException;
&nbsp;
&nbsp;	/**
&nbsp;	 * Completely removes an order group attribute type from the database
&nbsp;	 *
&nbsp;	 * @param orderGroupAttributeType The order group attribute type to purge
&nbsp;	 * @should completely remove an order group attribute type
&nbsp;	 */
&nbsp;    @Authorized(PrivilegeConstants.PURGE_ORDERS)
&nbsp;	void purgeOrderGroupAttributeType(OrderGroupAttributeType orderGroupAttributeType) throws APIException;
&nbsp;
&nbsp;	/**
&nbsp;	 * Retrieves an order group attribute type object based on the name provided
&nbsp;	 *
&nbsp;	 * @param orderGroupAttributeTypeName The name of the order group attribute type to fetch
&nbsp;	 * @return the {@link OrderGroupAttributeType} with the specified name
&nbsp;	 * @should return the order group attribute type with the specified name
&nbsp;	 * @should return null if no order group attribute type exists with the specified name
&nbsp;	 */
&nbsp;    @Authorized(PrivilegeConstants.GET_ORDERS)
&nbsp;	OrderGroupAttributeType getOrderGroupAttributeTypeByName(String orderGroupAttributeTypeName) throws APIException;
&nbsp;    
&nbsp;	/**
&nbsp;	 * Fetches a given order group attribute using the provided uuid
&nbsp;	 * 
&nbsp;	 * @param uuid The uuid of the order group attribute to fetch
&nbsp;	 * @return the {@link OrderGroupAttribute} with the given uuid
&nbsp;	 * @since 2.4.0
&nbsp;	 * @should get the order group attribute with the given uuid
&nbsp;	 * @should return null if no order group attribute has the given uuid
&nbsp;	 */
&nbsp;	@Authorized(PrivilegeConstants.GET_ORDERS)
&nbsp;	OrderGroupAttribute getOrderGroupAttributeByUuid(String uuid) throws APIException;
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns all order attribute types
&nbsp;	 *
&nbsp;	 * @return all {@link OrderAttributeType}s
&nbsp;	 * @since 2.5.0
&nbsp;	 * @should return all order attribute types including retired ones
&nbsp;	 */
&nbsp;	@Authorized(PrivilegeConstants.GET_ORDERS)
&nbsp;	List&lt;OrderAttributeType&gt; getAllOrderAttributeTypes() throws APIException;
&nbsp;
&nbsp;	/**
&nbsp;	 * Fetches order attribute type using provided Id
&nbsp;	 *
&nbsp;	 * @param id The Id of the order attribute type to fetch from the database
&nbsp;	 * @return the {@link OrderAttributeType} with the given internal id
&nbsp;	 * @since 2.5.0
&nbsp;	 * @should return the order attribute type using the provided id
&nbsp;	 * @should return null if no order attribute type exists with the given id
&nbsp;	 */
&nbsp;	@Authorized(PrivilegeConstants.GET_ORDERS)
&nbsp;	OrderAttributeType getOrderAttributeTypeById(Integer orderAttributeTypeId) throws APIException;
&nbsp;
&nbsp;	/**
&nbsp;	 * Fetches order attribute type using provided uuid
&nbsp;	 *
&nbsp;	 * @param uuid The uuid of the order attribute type to fetch from the database
&nbsp;	 * @return the {@link OrderAttributeType} with the given uuid
&nbsp;	 * @since 2.5.0
&nbsp;	 * @should return the order attribute type with the given uuid
&nbsp;	 * @should return null if no order attribute type exists with the given uuid
&nbsp;	 */
&nbsp;	OrderAttributeType getOrderAttributeTypeByUuid(String uuid) throws APIException;
&nbsp;
&nbsp;	/**
&nbsp;	 * Creates or updates the given order attribute type in the database
&nbsp;	 *
&nbsp;	 * @param orderAttributeType The order attribute type to save in the database
&nbsp;	 * @return the order attribute type created or saved
&nbsp;	 * @since 2.5.0
&nbsp;	 * @should create a new order attribute type
&nbsp;	 * @should edit an existing order attribute type
&nbsp;	 */
&nbsp;	@Authorized({PrivilegeConstants.EDIT_ORDERS,PrivilegeConstants.ADD_ORDERS})
&nbsp;	OrderAttributeType saveOrderAttributeType(OrderAttributeType orderAttributeType) throws APIException;
&nbsp;
&nbsp;	/**
&nbsp;	 * Retires the given order attribute type in the database
&nbsp;	 *
&nbsp;	 * @param orderAttributeType The order attribute type to retire
&nbsp;	 * @param reason The reason why the order attribute type is being retired
&nbsp;	 * @return the order attribute type retired
&nbsp;	 * @since 2.5.0
&nbsp;	 * @should retire an order attribute type
&nbsp;	 */
&nbsp;	@Authorized(PrivilegeConstants.MANAGE_ORDER_TYPES)
&nbsp;	OrderAttributeType retireOrderAttributeType(OrderAttributeType orderAttributeType, String reason) throws APIException;
&nbsp;
&nbsp;	/**
&nbsp;	 * Restores an order attribute type that was previously retired in the database
&nbsp;	 *
&nbsp;	 * @param orderAttributeType The order attribute type to unretire
&nbsp;	 * @return the order attribute type unretired
&nbsp;	 * @since 2.5.0
&nbsp;	 * @should unretire an order attribute type
&nbsp;	 */
&nbsp;	@Authorized(PrivilegeConstants.MANAGE_ORDER_TYPES)
&nbsp;	OrderAttributeType unretireOrderAttributeType(OrderAttributeType orderAttributeType) throws APIException;
&nbsp;
&nbsp;	/**
&nbsp;	 * Completely removes an order attribute type from the database
&nbsp;	 *
&nbsp;	 * @param orderAttributeType The order attribute type to purge
&nbsp;	 * @since 2.5.0
&nbsp;	 * @should completely remove an order attribute type
&nbsp;	 */
&nbsp;	@Authorized(PrivilegeConstants.PURGE_ORDERS)
&nbsp;	void purgeOrderAttributeType(OrderAttributeType orderAttributeType) throws APIException;
&nbsp;
&nbsp;	/**
&nbsp;	 * Retrieves an order attribute type object based on the name provided
&nbsp;	 *
&nbsp;	 * @param orderAttributeTypeName The name of the order attribute type to fetch
&nbsp;	 * @return the {@link OrderAttributeType} with the specified name
&nbsp;	 * @since 2.5.0
&nbsp;	 * @should return the order attribute type with the specified name
&nbsp;	 * @should return null if no order attribute type exists with the specified name
&nbsp;	 */
&nbsp;	@Authorized(PrivilegeConstants.GET_ORDERS)
&nbsp;	OrderAttributeType getOrderAttributeTypeByName(String orderAttributeTypeName) throws APIException;
&nbsp;
&nbsp;	/**
&nbsp;	 * Fetches a given order attribute using the provided uuid
&nbsp;	 *
&nbsp;	 * @param uuid The uuid of the order attribute to fetch
&nbsp;	 * @return the {@link OrderAttribute} with the given uuid
&nbsp;	 * @since 2.5.0
&nbsp;	 * @should get the order attribute with the given uuid
&nbsp;	 * @should return null if no order attribute has the given uuid
&nbsp;	 */
&nbsp;	@Authorized(PrivilegeConstants.GET_ORDERS)
&nbsp;	OrderAttribute getOrderAttributeByUuid(String uuid) throws APIException;
&nbsp;
&nbsp;	/**
&nbsp;	 * @see org.openmrs.api.OrderService#getActiveOrders(org.openmrs.Patient, org.openmrs.OrderType,
&nbsp;	 *      org.openmrs.CareSetting, java.util.Date)
&nbsp;	 *      
&nbsp;	 * This method works exactly the same; it only adds visit to the search criteria.
&nbsp;	 * It effectively surpasses the above method; the old one is however kept for backward
&nbsp;	 * compatibility reasons.
&nbsp;	 * 
&nbsp;	 * @param visit the {@link Visit} to restrict active orders (optional)
&nbsp;	 *      
&nbsp;	 * @since 2.7.0
&nbsp;	 */
&nbsp;	@Authorized(PrivilegeConstants.GET_ORDERS)
&nbsp;	public List&lt;Order&gt; getActiveOrders(Patient patient, Visit visit, OrderType orderType, CareSetting careSetting,
&nbsp;			Date asOfDate);
&nbsp;
&nbsp;	/**
&nbsp;	 * @see OrderService#getOrders(org.openmrs.Patient, org.openmrs.CareSetting,
&nbsp;	 *      org.openmrs.OrderType, boolean)
&nbsp;	 *      
&nbsp;	 * This method works exactly the same; it only adds visit to the search criteria.
&nbsp;	 * It effectively surpasses the above method; the old one is however kept for backward
&nbsp;	 * compatibility reasons.
&nbsp;	 * 
&nbsp;	 * @param visit the {@link Visit} to restrict orders (optional)
&nbsp;	 *      
&nbsp;	 * @since 2.7.0
&nbsp;	 */
&nbsp;	@Authorized(PrivilegeConstants.GET_ORDERS)
&nbsp;	public List&lt;Order&gt; getOrders(Patient patient, Visit visit, CareSetting careSetting, OrderType orderType,
&nbsp;			boolean includeVoided);
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-09-19 11:27</div>
</div>
</body>
</html>
